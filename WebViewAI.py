"""
BrowserAI_Universal.py - ÂÖ®WebË™çË≠òÂØæÂøú„Éñ„É©„Ç¶„Ç∂Êìç‰ΩúÁõ£Ë¶ñ„ÉÑ„Éº„É´
„Éö„Éº„Ç∏ÈÅ∑Áßª„ÄÅ„É™„ÉÄ„Ç§„É¨„ÇØ„Éà„ÄÅSPAÂØæÂøú„ÅßWebÂÖ®‰Ωì„ÇíÁ∂ôÁ∂öÁõ£Ë¶ñ
„Éñ„É©„Ç¶„Ç∂„ÇØ„É≠„Éº„Ç∫Ëá™ÂãïÊ§úÂá∫„ÉªÂÅúÊ≠¢Ê©üËÉΩ‰ªò„Åç
„Ç≥„Éû„É≥„Éâ„É©„Ç§„É≥ÂºïÊï∞ÂØæÂøúÁâà
"""

import asyncio
import json
import time
import threading
from datetime import datetime
import websockets
import logging
import os
import sys
import argparse
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, WebDriverException
from webdriver_manager.chrome import ChromeDriverManager
import traceback
from urllib.parse import urlparse, urljoin

class UniversalBrowserAI:
    """ÂÖ®WebË™çË≠òÂØæÂøú„Éñ„É©„Ç¶„Ç∂AIÁõ£Ë¶ñ„ÇØ„É©„Çπ"""
    
    def __init__(self, websocket_port: int = 8765):
        self.websocket_port = websocket_port
        self.operation_log = []
        self.console_log = []
        self.navigation_log = []
        self.connected_clients = set()
        self.is_monitoring = False
        self.driver = None
        self.current_url = None
        self.previous_url = None
        self.allowed_domains = set()
        self.monitoring_injected = False
        self.url_check_interval = 0.5  # URLÂ§âÊõ¥„ÉÅ„Çß„ÉÉ„ÇØÈñìÈöîÔºàÁßíÔºâ
        self.browser_closed = False  # „Éñ„É©„Ç¶„Ç∂„ÇØ„É≠„Éº„Ç∫Áä∂ÊÖã„Éï„É©„Ç∞
        self.auto_stop_enabled = True  # Ëá™ÂãïÂÅúÊ≠¢Ê©üËÉΩ„ÅÆÊúâÂäπÂåñ
        
        # „É≠„Ç∞Ë®≠ÂÆö
        logging.basicConfig(level=logging.INFO)
        self.logger = logging.getLogger(__name__)
        self.logger.info("Universal BrowserAI Monitor initialized")

    def add_allowed_domain(self, url: str):
        """Áõ£Ë¶ñÂØæË±°„Éâ„É°„Ç§„É≥„ÇíËøΩÂä†"""
        parsed = urlparse(url)
        domain = f"{parsed.scheme}://{parsed.netloc}"
        self.allowed_domains.add(domain)
        self.logger.info(f"Added allowed domain: {domain}")

    def is_url_allowed(self, url: str) -> bool:
        """URL„ÅåÁõ£Ë¶ñÂØæË±°„Åã„ÉÅ„Çß„ÉÉ„ÇØ"""
        if not self.allowed_domains:
            return True  # „Éâ„É°„Ç§„É≥Âà∂Èôê„Å™„Åó„ÅÆÂ†¥Âêà„ÅØÂÖ®„Å¶Ë®±ÂèØ
        
        parsed = urlparse(url)
        domain = f"{parsed.scheme}://{parsed.netloc}"
        return domain in self.allowed_domains

    def is_browser_alive(self) -> bool:
        """„Éñ„É©„Ç¶„Ç∂„Çª„ÉÉ„Ç∑„Éß„É≥„ÅåÁîü„Åç„Å¶„ÅÑ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ"""
        try:
            if not self.driver:
                return False
            
            # Á∞°Âçò„Å™JavaScript„ÇíÂÆüË°å„Åó„Å¶„Çª„ÉÉ„Ç∑„Éß„É≥„Çí„ÉÜ„Çπ„Éà
            self.driver.execute_script("return true;")
            return True
            
        except (WebDriverException, Exception):
            return False

    def setup_chrome_driver(self, headless: bool = False):
        """Chrome„Éâ„É©„Ç§„Éê„Éº„ÅÆ„Çª„ÉÉ„Éà„Ç¢„ÉÉ„Éó"""
        try:
            chrome_options = Options()
            if headless:
                chrome_options.add_argument("--headless")
            
            # „É≠„Ç∞„É¨„Éô„É´„ÇíË®≠ÂÆö„Åó„Å¶„Ç≥„É≥„ÇΩ„Éº„É´„É≠„Ç∞„ÇíÂèñÂæó
            chrome_options.add_argument("--enable-logging")
            chrome_options.add_argument("--log-level=0")
            chrome_options.add_experimental_option('useAutomationExtension', False)
            chrome_options.add_experimental_option("excludeSwitches", ["enable-automation"])
            
            # „Çª„Ç≠„É•„É™„ÉÜ„Ç£Ë®≠ÂÆö„ÇíÁ∑©ÂíåÔºàÈñãÁô∫Áî®Ôºâ
            chrome_options.add_argument("--disable-web-security")
            chrome_options.add_argument("--disable-features=VizDisplayCompositor")
            chrome_options.add_argument("--allow-running-insecure-content")
            
            # „É≠„Ç∞„ÇíÊúâÂäπ„Å´„Åô„Çã
            chrome_options.set_capability('goog:loggingPrefs', {'browser': 'ALL'})
            
            # WebDriverManager„Çí‰ΩøÁî®„Åó„Å¶ChromeDriver„ÇíËá™ÂãïÂèñÂæó
            service = Service(ChromeDriverManager().install())
            self.driver = webdriver.Chrome(service=service, options=chrome_options)
            
            self.logger.info("Chrome driver setup completed")
            return True
            
        except Exception as e:
            self.logger.error(f"Failed to setup Chrome driver: {e}")
            return False

    def inject_universal_monitoring_script(self):
        """„Éö„Éº„Ç∏„Å´„É¶„Éã„Éê„Éº„Çµ„É´„É¢„Éã„Çø„É™„É≥„Ç∞Áî®„ÅÆJavaScript„ÇíÊ≥®ÂÖ•"""
        script = f"""
        (function() {{
            if (window.universalMonitoringInjected) return;
            window.universalMonitoringInjected = true;
            
            console.log('üîß Universal Monitoring Script Injected');
            
            const ws = new WebSocket('ws://localhost:{self.websocket_port}');
            
            function sendOperation(operation) {{
                if (ws.readyState === WebSocket.OPEN) {{
                    ws.send(JSON.stringify(operation));
                }}
            }}
            
            // „ÇØ„É™„ÉÉ„ÇØ„Ç§„Éô„É≥„ÉàÁõ£Ë¶ñ
            document.addEventListener('click', function(e) {{
                sendOperation({{
                    type: 'click',
                    timestamp: new Date().toISOString(),
                    element: e.target.tagName,
                    class: e.target.className,
                    id: e.target.id,
                    text: e.target.textContent ? e.target.textContent.substring(0, 100) : '',
                    url: window.location.href,
                    x: e.clientX,
                    y: e.clientY
                }});
            }});
            
            // „Ç≠„Éº„Éú„Éº„ÉâÂÖ•ÂäõÁõ£Ë¶ñ
            document.addEventListener('keydown', function(e) {{
                sendOperation({{
                    type: 'keydown',
                    timestamp: new Date().toISOString(),
                    key: e.key,
                    element: e.target.tagName,
                    url: window.location.href
                }});
            }});
            
            // „Éï„Ç©„Éº„É†ÈÄÅ‰ø°Áõ£Ë¶ñ
            document.addEventListener('submit', function(e) {{
                sendOperation({{
                    type: 'form_submit',
                    timestamp: new Date().toISOString(),
                    form_action: e.target.action,
                    form_method: e.target.method,
                    url: window.location.href
                }});
            }});
            
            // „Éö„Éº„Ç∏ÈÅ∑ÁßªÁõ£Ë¶ñÔºàpushState/replaceStateÂØæÂøúÔºâ
            const originalPushState = history.pushState;
            const originalReplaceState = history.replaceState;
            
            history.pushState = function() {{
                originalPushState.apply(history, arguments);
                setTimeout(() => {{
                    sendOperation({{
                        type: 'navigation',
                        timestamp: new Date().toISOString(),
                        from: document.referrer,
                        to: window.location.href,
                        method: 'pushState'
                    }});
                }}, 100);
            }};
            
            history.replaceState = function() {{
                originalReplaceState.apply(history, arguments);
                setTimeout(() => {{
                    sendOperation({{
                        type: 'navigation',
                        timestamp: new Date().toISOString(),
                        from: document.referrer,
                        to: window.location.href,
                        method: 'replaceState'
                    }});
                }}, 100);
            }};
            
            // popstate „Ç§„Éô„É≥„ÉàÔºàÊàª„Çã/ÈÄ≤„ÇÄ„Éú„Çø„É≥Ôºâ
            window.addEventListener('popstate', function(e) {{
                sendOperation({{
                    type: 'navigation',
                    timestamp: new Date().toISOString(),
                    from: document.referrer,
                    to: window.location.href,
                    method: 'popstate'
                }});
            }});
            
            // JS„Ç®„É©„ÉºÁõ£Ë¶ñ
            window.addEventListener('error', function(e) {{
                sendOperation({{
                    type: 'error',
                    timestamp: new Date().toISOString(),
                    message: e.message,
                    filename: e.filename,
                    lineno: e.lineno,
                    colno: e.colno,
                    url: window.location.href
                }});
            }});
            
            // Promise rejection„Ç®„É©„ÉºÁõ£Ë¶ñ
            window.addEventListener('unhandledrejection', function(e) {{
                sendOperation({{
                    type: 'promise_rejection',
                    timestamp: new Date().toISOString(),
                    reason: e.reason ? e.reason.toString() : 'Unknown',
                    url: window.location.href
                }});
            }});
            
            // WebSocketÊé•Á∂öÁä∂ÊÖã„ÅÆ„É≠„Ç∞
            ws.onopen = function() {{
                console.log('üîó WebSocket connected to monitoring server');
                sendOperation({{
                    type: 'websocket_connected',
                    timestamp: new Date().toISOString(),
                    url: window.location.href
                }});
            }};
            
            ws.onerror = function(error) {{
                console.error('‚ùå WebSocket error:', error);
            }};
            
            ws.onclose = function() {{
                console.log('üîå WebSocket connection closed');
            }};
        }})();
        """
        
        try:
            self.driver.execute_script(script)
            self.logger.info("‚úÖ Universal monitoring script injected successfully")
            self.monitoring_injected = True
        except Exception as e:
            self.logger.error(f"Failed to inject monitoring script: {e}")

    async def websocket_handler(self, websocket):
        """WebSocket„Åã„Çâ„ÅÆ„Éá„Éº„Çø„ÇíÂá¶ÁêÜ"""
        client_id = id(websocket)
        self.connected_clients.add(client_id)
        self.logger.info(f"üì± Client connected: {client_id}")
        
        try:
            async for message in websocket:
                try:
                    data = json.loads(message)
                    data['client_id'] = client_id
                    
                    # Êìç‰Ωú„Çø„Ç§„Éó„Å´Âøú„Åò„Å¶ÈÅ©Âàá„Å™„É≠„Ç∞„Å´Ë®òÈå≤
                    if data.get('type') == 'navigation':
                        self.navigation_log.append({
                            'timestamp': data.get('timestamp'),
                            'operation': data
                        })
                        self.logger.info(f"üîó Navigation: {data.get('to')}")
                    else:
                        self.operation_log.append(data)
                        if data.get('type') == 'click':
                            self.logger.info(f"üñ±Ô∏è  Click: {data.get('element')} - {data.get('text', '')[:50]}")
                        elif data.get('type') == 'keydown':
                            self.logger.info(f"‚å®Ô∏è  Key: {data.get('key')}")
                    
                except json.JSONDecodeError:
                    self.logger.error(f"Invalid JSON received: {message}")
                except Exception as e:
                    self.logger.error(f"Error processing message: {e}")
                    
        except websockets.exceptions.ConnectionClosed:
            self.logger.info(f"üîå Client disconnected: {client_id}")
        except Exception as e:
            self.logger.error(f"WebSocket handler error: {e}")
        finally:
            self.connected_clients.discard(client_id)

    async def start_websocket_server(self):
        """WebSocket„Çµ„Éº„Éê„Éº„ÇíÈñãÂßã"""
        self.logger.info(f"Starting WebSocket server on ws://localhost:{self.websocket_port}")
        server = await websockets.serve(
            self.websocket_handler,
            "localhost",
            self.websocket_port
        )
        await server.wait_closed()

    def monitor_url_changes(self):
        """URLÂ§âÊõ¥„ÇíÁ∂ôÁ∂öÁöÑ„Å´Áõ£Ë¶ñ„Åó„Å¶„Çπ„ÇØ„É™„Éó„Éà„ÇíÂÜçÊ≥®ÂÖ•"""
        while self.is_monitoring and not self.browser_closed:
            try:
                if not self.is_browser_alive():
                    self.browser_closed = True
                    self.logger.info("üî¥ „Éñ„É©„Ç¶„Ç∂„Çª„ÉÉ„Ç∑„Éß„É≥ÁµÇ‰∫Ü„ÇíÊ§úÂá∫")
                    break
                
                current_url = self.driver.current_url
                if current_url != self.current_url:
                    self.logger.info(f"üîÑ URL changed: {self.current_url} -> {current_url}")
                    self.previous_url = self.current_url
                    self.current_url = current_url
                    
                    # Êñ∞„Åó„ÅÑURL„Åå„Éâ„É°„Ç§„É≥Âà∂Èôê„Å´ÈÅïÂèç„Åó„Å¶„ÅÑ„Å™„ÅÑ„Åã„ÉÅ„Çß„ÉÉ„ÇØ
                    if self.allowed_domains and not self.is_url_allowed(current_url):
                        self.logger.warning(f"‚ö†Ô∏è URL outside allowed domains: {current_url}")
                    
                    # „É¢„Éã„Çø„É™„É≥„Ç∞„Çπ„ÇØ„É™„Éó„Éà„ÇíÂÜçÊ≥®ÂÖ•
                    time.sleep(1)  # „Éö„Éº„Ç∏Ë™≠„ÅøËæº„ÅøÂæÖ„Å°
                    self.inject_universal_monitoring_script()
                    
                    # „Éä„Éì„Ç≤„Éº„Ç∑„Éß„É≥„É≠„Ç∞„Å´Ë®òÈå≤
                    self.navigation_log.append({
                        'timestamp': datetime.now().isoformat(),
                        'operation': {
                            'type': 'navigation',
                            'from': self.previous_url,
                            'to': current_url,
                            'method': 'url_change_detected'
                        }
                    })
                
                time.sleep(self.url_check_interval)
                
            except Exception as e:
                if "invalid session id" in str(e).lower() or "session deleted" in str(e).lower():
                    self.browser_closed = True
                    self.logger.info("üî¥ „Éñ„É©„Ç¶„Ç∂„Çª„ÉÉ„Ç∑„Éß„É≥ÁÑ°ÂäπÂåñ„ÇíÊ§úÂá∫")
                    break
                else:
                    self.logger.error(f"URLÁõ£Ë¶ñ„Ç®„É©„Éº: {e}")
                    time.sleep(1)

    def collect_browser_logs(self):
        """„Éñ„É©„Ç¶„Ç∂„ÅÆ„Ç≥„É≥„ÇΩ„Éº„É´„É≠„Ç∞„ÇíÂèéÈõÜ"""
        try:
            if self.driver and not self.browser_closed:
                logs = self.driver.get_log('browser')
                for log in logs:
                    self.console_log.append({
                        'timestamp': datetime.fromtimestamp(log['timestamp'] / 1000).isoformat(),
                        'level': log['level'],
                        'message': log['message'],
                        'source': log.get('source', 'unknown'),
                        'url': self.current_url
                    })
        except Exception as e:
            if "invalid session id" in str(e).lower() or "session deleted" in str(e).lower():
                self.browser_closed = True
                self.logger.info("üî¥ „Éñ„É©„Ç¶„Ç∂„Çª„ÉÉ„Ç∑„Éß„É≥ÁµÇ‰∫ÜÔºà„É≠„Ç∞ÂèéÈõÜÊôÇÔºâ")
            else:
                self.logger.error(f"„Ç≥„É≥„ÇΩ„Éº„É´„É≠„Ç∞ÂèéÈõÜ„Ç®„É©„Éº: {e}")

    def navigate_to_url(self, url: str):
        """ÊåáÂÆö„Åï„Çå„ÅüURL„Å´ÁßªÂãï"""
        try:
            self.current_url = url
            self.add_allowed_domain(url)  # ÂàùÊúüURL„ÅØ„Éâ„É°„Ç§„É≥Ë®±ÂèØ„É™„Çπ„Éà„Å´ËøΩÂä†
            
            self.logger.info(f"Navigating to: {url}")
            self.driver.get(url)
            
            # „Éö„Éº„Ç∏„ÅÆË™≠„ÅøËæº„ÅøÂÆå‰∫Ü„ÇíÂæÖ„Å§
            WebDriverWait(self.driver, 10).until(
                lambda driver: driver.execute_script("return document.readyState") == "complete"
            )
            
            # „É¢„Éã„Çø„É™„É≥„Ç∞„Çπ„ÇØ„É™„Éó„Éà„ÇíÊ≥®ÂÖ•
            time.sleep(1)  # „Éö„Éº„Ç∏„ÅåÂÆåÂÖ®„Å´Ë™≠„ÅøËæº„Åæ„Çå„Çã„Åæ„ÅßÂæÖÊ©ü
            self.inject_universal_monitoring_script()
            
            self.logger.info(f"Successfully navigated to {url}")
            return True
            
        except TimeoutException:
            self.logger.error(f"Timeout while loading {url}")
            return False
        except Exception as e:
            self.logger.error(f"Error navigating to {url}: {e}")
            return False

    def stop_monitoring(self):
        """Áõ£Ë¶ñ„ÇíÂÅúÊ≠¢„Åó„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó„ÇíÂÆüË°å"""
        try:
            self.logger.info("üõë Áõ£Ë¶ñÂÅúÊ≠¢Âá¶ÁêÜ„ÇíÈñãÂßã...")
            self.is_monitoring = False
            
            # „É¨„Éù„Éº„Éà„ÇíËá™ÂãïÂá∫Âäõ
            if hasattr(self, 'operation_log') and (self.operation_log or self.console_log or self.navigation_log):
                self.logger.info("üìä Áõ£Ë¶ñ„Éá„Éº„Çø„Çí„É¨„Éù„Éº„Éà„Å´Âá∫Âäõ‰∏≠...")
                report_file = self.export_report()
                self.logger.info(f"‚úÖ „É¨„Éù„Éº„ÉàÂá∫ÂäõÂÆå‰∫Ü: {report_file}")
            
        except Exception as e:
            self.logger.error(f"Error during stop monitoring: {e}")

    def cleanup_driver(self):
        """„Éâ„É©„Ç§„Éê„Éº„ÅÆ„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó"""
        try:
            if self.driver:
                self.logger.info("üßπ „Éñ„É©„Ç¶„Ç∂„Éâ„É©„Ç§„Éê„Éº„Çí„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó‰∏≠...")
                self.driver.quit()
                self.driver = None
                self.logger.info("‚úÖ „Éâ„É©„Ç§„Éê„Éº„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„ÉóÂÆå‰∫Ü")
        except Exception as e:
            self.logger.error(f"Error during driver cleanup: {e}")

    def start_monitoring(self, url: str, duration: int = 60, allowed_domains: list = None):
        """Áõ£Ë¶ñÈñãÂßã"""
        try:
            self.is_monitoring = True
            self.browser_closed = False
            
            # Ë®±ÂèØ„Éâ„É°„Ç§„É≥„ÇíË®≠ÂÆö
            if allowed_domains is not None:  # None„Åß„Å™„ÅÑÂ†¥Âêà„ÅÆ„Åø„Éâ„É°„Ç§„É≥Âà∂Èôê„ÇíË®≠ÂÆö
                for domain in allowed_domains:
                    self.add_allowed_domain(domain)
            # allowed_domains „Åå None „ÅÆÂ†¥Âêà„ÅØÂÖ®„Éâ„É°„Ç§„É≥Ë®±ÂèØÔºàÂà∂Èôê„Å™„ÅóÔºâ
            
            # Chrome„Éâ„É©„Ç§„Éê„Éº„ÇíË®≠ÂÆö
            if not self.setup_chrome_driver():
                raise Exception("Failed to setup Chrome driver")
            
            # WebSocket„Çµ„Éº„Éê„Éº„ÇíÂà•„Çπ„É¨„ÉÉ„Éâ„ÅßÈñãÂßã
            def run_websocket():
                asyncio.run(self.start_websocket_server())
            
            server_thread = threading.Thread(target=run_websocket, daemon=True)
            server_thread.start()
            
            # URLÁõ£Ë¶ñ„ÇíÂà•„Çπ„É¨„ÉÉ„Éâ„ÅßÈñãÂßã
            url_monitor_thread = threading.Thread(target=self.monitor_url_changes, daemon=True)
            url_monitor_thread.start()
            
            # „Çµ„Éº„Éê„ÉºËµ∑ÂãïÂæÖ„Å°
            time.sleep(2)
            
            # ÊåáÂÆö„Åï„Çå„ÅüURL„Å´ÁßªÂãï
            if not self.navigate_to_url(url):
                raise Exception(f"Failed to navigate to {url}")
            
            self.logger.info(f"üéØ Universal monitoring started for {duration} seconds on {url}")
            self.logger.info("üåê „Éö„Éº„Ç∏ÈÅ∑Áßª„ÇÑ„É™„ÉÄ„Ç§„É¨„ÇØ„Éà„ÇÇËá™ÂãïËøΩË∑°„Åó„Åæ„Åô")
            self.logger.info("üì± Êìç‰Ωú„ÇíÈñãÂßã„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºà„ÇØ„É™„ÉÉ„ÇØ„ÄÅ„É™„É≥„ÇØ„ÄÅÂÖ•ÂäõÁ≠âÔºâ")
            self.logger.info("üî¥ „Éñ„É©„Ç¶„Ç∂„ÇíÈñâ„Åò„Çã„Å®Ëá™ÂãïÁöÑ„Å´Áõ£Ë¶ñ„ÅåÂÅúÊ≠¢„Åï„Çå„Åæ„Åô")
            
            # Áõ£Ë¶ñÊúüÈñì‰∏≠ÂæÖÊ©ü
            start_time = time.time()
            while self.is_monitoring and (time.time() - start_time) < duration and not self.browser_closed:
                # „Éñ„É©„Ç¶„Ç∂„ÅÆ„Ç≥„É≥„ÇΩ„Éº„É´„É≠„Ç∞„ÇíÂÆöÊúüÁöÑ„Å´ÂèéÈõÜ
                self.collect_browser_logs()
                
                # „Éñ„É©„Ç¶„Ç∂„ÇØ„É≠„Éº„Ç∫„Çí„ÉÅ„Çß„ÉÉ„ÇØ
                if self.browser_closed:
                    self.logger.info("üî¥ „Éñ„É©„Ç¶„Ç∂„ÇØ„É≠„Éº„Ç∫„ÅåÊ§úÂá∫„Åï„Çå„Åæ„Åó„Åü")
                    break
                
                time.sleep(1)
                
                if int(time.time() - start_time) % 10 == 0 and not self.browser_closed:
                    self.logger.info(
                        f"üìä Stats - Operations: {len(self.operation_log)}, "
                        f"Console: {len(self.console_log)}, "
                        f"Navigations: {len(self.navigation_log)}, "
                        f"Current URL: {self.current_url}"
                    )
            
            # Áõ£Ë¶ñÁµÇ‰∫ÜÁêÜÁî±„Çí„É≠„Ç∞Âá∫Âäõ
            if self.browser_closed:
                self.logger.info("üî¥ „Éñ„É©„Ç¶„Ç∂„ÇØ„É≠„Éº„Ç∫„Å´„Çà„ÇäÁõ£Ë¶ñÁµÇ‰∫Ü")
            elif (time.time() - start_time) >= duration:
                self.logger.info("‚è∞ ÊåáÂÆöÊôÇÈñìÁµåÈÅé„Å´„Çà„ÇäÁõ£Ë¶ñÁµÇ‰∫Ü")
            else:
                self.logger.info("üõë ÊâãÂãïÂÅúÊ≠¢„Å´„Çà„ÇäÁõ£Ë¶ñÁµÇ‰∫Ü")
            
            self.logger.info("Universal monitoring completed")
            
        except Exception as e:
            self.logger.error(f"Error during monitoring: {e}")
            traceback.print_exc()
            raise
        finally:
            # Ëá™ÂãïÂÅúÊ≠¢Âá¶ÁêÜ
            if not self.browser_closed and self.auto_stop_enabled:
                self.stop_monitoring()
            
            # „Éâ„É©„Ç§„Éê„Éº„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
            self.cleanup_driver()

    def export_report(self) -> str:
        """Êã°Âºµ„É¨„Éù„Éº„ÉàÂá∫Âäõ"""
        filename = f"universal_browser_ai_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        
        # „É¶„Éã„Éº„ÇØ„Å™URL„ÇíÂèñÂæó
        visited_urls = set()
        for nav in self.navigation_log:
            if isinstance(nav, dict) and 'to' in nav:
                visited_urls.add(nav['to'])
            elif isinstance(nav, dict) and 'operation' in nav:
                visited_urls.add(nav['operation'].get('data', {}).get('to'))
        
        if self.current_url:
            visited_urls.add(self.current_url)
        
        report = {
            "timestamp": datetime.now().isoformat(),
            "session_summary": {
                "start_url": next(iter(self.allowed_domains)) if self.allowed_domains else None,
                "current_url": self.current_url,
                "total_operations": len(self.operation_log),
                "total_console_logs": len(self.console_log),
                "total_navigations": len(self.navigation_log),
                "visited_urls": list(visited_urls),
                "allowed_domains": list(self.allowed_domains),
                "browser_closed": self.browser_closed,
                "monitoring_completed": not self.is_monitoring
            },
            "operations": self.operation_log,
            "console_logs": self.console_log,
            "navigation_log": self.navigation_log
        }
        
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
        
        self.logger.info(f"Universal report exported: {filename}")
        return filename

def main():
    """„Ç≥„Éû„É≥„Éâ„É©„Ç§„É≥ÂºïÊï∞„Åæ„Åü„ÅØ„Ç§„É≥„Çø„É©„ÇØ„ÉÜ„Ç£„Éñ„É¢„Éº„Éâ„ÅßÂÆüË°å"""
    parser = argparse.ArgumentParser(
        description="üåê Universal BrowserAI Monitoring Tool - „Éö„Éº„Ç∏ÈÅ∑Áßª„Éª„É™„ÉÄ„Ç§„É¨„ÇØ„ÉàÂØæÂøú WebÂÖ®‰ΩìË™çË≠òÁõ£Ë¶ñ",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
‰ΩøÁî®‰æã:
  # „É≠„Éº„Ç´„É´„Éï„Ç°„Ç§„É´„ÇíÁõ£Ë¶ñÔºàËá™ÂãïÂåñÁî®Ôºâ
  python browseAI.py --path "tool/File/Clicker/rpg.html" --time 120
  
  # HTTP„Çµ„Éº„Éê„Éº„ÇíÁõ£Ë¶ñÔºàËá™ÂãïÂåñÁî®Ôºâ
  python browseAI.py --path "http://localhost:8080/tool/File/Clicker/rpg.html" --domain "http://localhost:8080" --time 60
  
  # ÂÖ®„Éâ„É°„Ç§„É≥Ë®±ÂèØ„ÅßÁõ£Ë¶ñ
  python browseAI.py --path "https://example.com" --domain all --time 90
  
  # Ë§áÊï∞„Éâ„É°„Ç§„É≥Ë®±ÂèØ
  python browseAI.py --path "https://example.com" --domain "https://example.com,https://api.example.com" --time 60
  
  # „Ç§„É≥„Çø„É©„ÇØ„ÉÜ„Ç£„Éñ„É¢„Éº„ÉâÔºàÂºïÊï∞„Å™„ÅóÔºâ
  python browseAI.py
        """
    )
    
    parser.add_argument(
        '--path', 
        type=str, 
        help='Áõ£Ë¶ñÈñãÂßãURL „Åæ„Åü„ÅØ„É≠„Éº„Ç´„É´„Éï„Ç°„Ç§„É´„Éë„ÇπÔºà‰æã: "tool/File/Clicker/rpg.html" „Åæ„Åü„ÅØ "http://localhost:8080"Ôºâ'
    )
    parser.add_argument(
        '--domain', 
        type=str, 
        help='Ë®±ÂèØ„Éâ„É°„Ç§„É≥Ë®≠ÂÆö„ÄÇ"all" „ÅßÂÖ®„Éâ„É°„Ç§„É≥Ë®±ÂèØ„ÄÅ„Ç´„É≥„ÉûÂå∫Âàá„Çä„ÅßË§áÊï∞ÊåáÂÆöÂèØËÉΩÔºà‰æã: "http://localhost:8080,https://example.com"Ôºâ'
    )
    parser.add_argument(
        '--time', 
        type=int, 
        default=60, 
        help='Áõ£Ë¶ñÊôÇÈñìÔºàÁßíÔºâ„ÄÇ„Éá„Éï„Ç©„É´„Éà: 60Áßí'
    )
    
    args = parser.parse_args()
    
    # „Éò„ÉÉ„ÉÄ„ÉºË°®Á§∫
    print("üåê Universal BrowserAI Monitoring Tool")
    print("=" * 70)
    print("üì± „Éö„Éº„Ç∏ÈÅ∑Áßª„Éª„É™„ÉÄ„Ç§„É¨„ÇØ„ÉàÂØæÂøú - WebÂÖ®‰ΩìË™çË≠òÁõ£Ë¶ñ")
    print("üî¥ „Éñ„É©„Ç¶„Ç∂„ÇØ„É≠„Éº„Ç∫Ëá™ÂãïÊ§úÂá∫„ÉªÂÅúÊ≠¢Ê©üËÉΩ‰ªò„Åç")
    print("=" * 70)
    
    # URL„Å®„Éâ„É°„Ç§„É≥„ÅÆÂá¶ÁêÜ
    if args.path:
        # „Ç≥„Éû„É≥„Éâ„É©„Ç§„É≥ÂºïÊï∞„É¢„Éº„ÉâÔºàËá™ÂãïÂåñÁî®Ôºâ
        target_url = args.path
        
        # „É≠„Éº„Ç´„É´„Éï„Ç°„Ç§„É´„Éë„Çπ„ÅÆÂ†¥Âêà„ÅØfile://„Çπ„Ç≠„Éº„É†„ÇíËøΩÂä†
        if not target_url.startswith(('http://', 'https://', 'file://')):
            # Áõ∏ÂØæ„Éë„Çπ„ÇíÁµ∂ÂØæ„Éë„Çπ„Å´Â§âÊèõ
            if not os.path.isabs(target_url):
                target_url = os.path.abspath(target_url)
            target_url = f"file:///{target_url.replace('\\', '/')}"
        
        # „Éâ„É°„Ç§„É≥Ë®≠ÂÆö„ÅÆÂá¶ÁêÜ
        allowed_domains = []
        if args.domain:
            if args.domain.lower() == 'all':
                allowed_domains = None  # ÂÖ®„Éâ„É°„Ç§„É≥Ë®±ÂèØ
                print("üåê Domain restriction: ÂÖ®„Éâ„É°„Ç§„É≥Ë®±ÂèØ")
            else:
                allowed_domains = [d.strip() for d in args.domain.split(',')]
                print(f"üåê Allowed domains: {allowed_domains}")
        else:
            allowed_domains = None  # Âà∂Èôê„Å™„Åó
            print("üåê Domain restriction: Âà∂Èôê„Å™„Åó")
        
        duration = args.time
        print(f"üéØ Target URL: {target_url}")
        print(f"‚è±Ô∏è  Duration: {duration} seconds")
        
    else:
        # „Ç§„É≥„Çø„É©„ÇØ„ÉÜ„Ç£„Éñ„É¢„Éº„Éâ
        target_url = input("Áõ£Ë¶ñÈñãÂßãURLÔºà‰æã: http://localhost:8080Ôºâ: ").strip()
        if not target_url:
            target_url = "http://localhost:8080"
        
        # Ë®±ÂèØ„Éâ„É°„Ç§„É≥„ÅÆË®≠ÂÆö
        domains_input = input("Áõ£Ë¶ñÂØæË±°„Éâ„É°„Ç§„É≥Ôºà„Ç´„É≥„ÉûÂå∫Âàá„Çä„ÄÅ'all'„ÅßÂà∂Èôê„Å™„Åó„ÄÅÁ©∫„Åß„Éá„Éï„Ç©„É´„ÉàÔºâ: ").strip()
        allowed_domains = []
        if domains_input:
            if domains_input.lower() == 'all':
                allowed_domains = None  # ÂÖ®„Éâ„É°„Ç§„É≥Ë®±ÂèØ
            else:
                allowed_domains = [d.strip() for d in domains_input.split(',')]
        else:
            allowed_domains = None  # Âà∂Èôê„Å™„Åó
        
        duration_input = input("Áõ£Ë¶ñÊôÇÈñìÔºàÁßí„ÄÅ„Éá„Éï„Ç©„É´„Éà60Ôºâ: ").strip()
        try:
            duration = int(duration_input) if duration_input else 60
        except ValueError:
            duration = 60
    
    monitor = UniversalBrowserAI()
    
    try:
        print("üî¥ „Éñ„É©„Ç¶„Ç∂„ÇíÈñâ„Åò„Çã„Å®Ëá™ÂãïÁöÑ„Å´Áõ£Ë¶ñ„ÅåÂÅúÊ≠¢„Åï„Çå„Åæ„Åô")
        print("=" * 70)
        
        # „É¶„Éã„Éê„Éº„Çµ„É´Áõ£Ë¶ñÈñãÂßã
        monitor.start_monitoring(target_url, duration, allowed_domains)
        
        # „É¨„Éù„Éº„ÉàÂá∫Âäõ
        if not monitor.browser_closed:
            report_file = monitor.export_report()
            print(f"\n‚úÖ Universal monitoring completed!")
        else:
            print(f"\nüî¥ Monitoring stopped due to browser closure!")
        
        print(f"üìä Operations collected: {len(monitor.operation_log)}")
        print(f"üìù Console logs collected: {len(monitor.console_log)}")
        print(f"üîó Page navigations: {len(monitor.navigation_log)}")
        
        # „É¨„Éù„Éº„Éà„ÅåËá™ÂãïÂá∫Âäõ„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑÂ†¥Âêà„ÅÆ„ÅøÊâãÂãïÂá∫Âäõ
        if hasattr(monitor, 'operation_log') and (monitor.operation_log or monitor.console_log or monitor.navigation_log):
            try:
                if not monitor.browser_closed:
                    report_file = monitor.export_report()
                    print(f"üìÑ Report saved: {report_file}")
                else:
                    print("üìÑ Report was automatically saved when browser was closed")
            except Exception as e:
                print(f"‚ö†Ô∏è Error saving report: {e}")
        
    except KeyboardInterrupt:
        print("\n‚èπÔ∏è Interrupted by user")
        # „É¶„Éº„Ç∂„Éº‰∏≠Êñ≠„ÅÆÂ†¥Âêà„ÇÇ„É¨„Éù„Éº„Éà„ÇíÂá∫Âäõ
        try:
            if hasattr(monitor, 'operation_log') and (monitor.operation_log or monitor.console_log or monitor.navigation_log):
                report_file = monitor.export_report()
                print(f"üìÑ Final report saved: {report_file}")
        except Exception as e:
            print(f"‚ö†Ô∏è Error saving final report: {e}")
    except Exception as e:
        print(f"‚ùå Error: {e}")
        traceback.print_exc()

if __name__ == "__main__":
    main()
